#pragma once
#include <cstdint>
#include <memory>

/// Interface to write little-endian bytes.
struct BinaryWritter
{
public:
    explicit BinaryWritter()
        : offset(0), max_offset(0)
    {}

    explicit BinaryWritter(size_t size) :
        offset(0), max_offset(size), bytecode(new uint8_t[size])
    {}

    /// \returns the buffer with the generated bytes.
    const void* buffer() const
    {
        return this->bytecode.get();
    }

    /// \returns the size of the buffer with the generated bytes.
    size_t buffer_size() const
    {
        return this->max_offset;
    }

    size_t current_offset() const
    {
        return this->offset;
    }

    void emplace_u8(uint8_t value)
    {
        assert(this->offset + 1 <= max_offset);
        bytecode[this->offset++] = reinterpret_cast<uint8_t&>(value);
    }

    void emplace_u16(uint16_t value)
    {
        // TODO maybe optimize, write a entire i16 at a time? is that portable?
        //assert(this->offset + 2 <= max_offset);
        emplace_u8((value & 0x00FF) >> 0);
        emplace_u8((value & 0xFF00) >> 8);
    }

    void emplace_u32(uint32_t value)
    {
        // TODO maybe optimize, write a entire i32 at a time? is that portable?
        //assert(this->offset + 4 <= max_offset);
        emplace_u8((value & 0x000000FF) >> 0);
        emplace_u8((value & 0x0000FF00) >> 8);
        emplace_u8((value & 0x00FF0000) >> 16);
        emplace_u8((value & 0xFF000000) >> 24);
    }

    void emplace_i8(int8_t value)
    {
        return emplace_u8(reinterpret_cast<uint8_t&>(value));
    }

    void emplace_i16(int16_t value)
    {
        return emplace_u16(reinterpret_cast<uint16_t&>(value));
    }

    void emplace_i32(int32_t value)
    {
        return emplace_u32(reinterpret_cast<uint32_t&>(value));
    }

    void emplace_bytes(size_t count, const void* bytes)
    {
        assert(this->offset + count <= max_offset);
        std::memcpy(&this->bytecode[offset], bytes, count);
        this->offset += count;
    }

    void emplace_fill(size_t count, uint8_t val)
    {
        assert(this->offset + count <= max_offset);
        std::memset(&this->bytecode[offset], val, count);
        this->offset += count;
    }

    void emplace_chars(size_t count, const char* data)
    {
        assert(this->offset + count <= max_offset);
        std::strncpy(reinterpret_cast<char*>(&this->bytecode[offset]), data, count);
        this->offset += count;
    }

    void emplace_chars(size_t count, const char* data, bool to_upper)
    {
        if(to_upper)
            return emplace_chars(count, data, ::toupper); // TODO FIXME toupper is bad
        else
            return emplace_chars(count, data);
    }

    template<typename FuncT>
    void emplace_chars(size_t count, const char* data, FuncT transform)
    {
        assert(this->offset + count <= max_offset);
        for(size_t i = 0; i < count; ++i)
        {
            if(*data == 0)
                this->bytecode[offset+i] = 0;
            else
                this->bytecode[offset+i] = transform(*data++);
        }
        this->offset += count;
    }

private:
    std::unique_ptr<uint8_t[]>  bytecode; // size == max_offset
    size_t                      offset;
    size_t                      max_offset;
};
