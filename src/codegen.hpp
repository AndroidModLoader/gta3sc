///
/// Code Generator
///
/// The code generator is responsible for converting the intermediate representation outputted by *compiler.hpp/cpp*
/// (stored as a vector of pseudo-instructions) into the final bytecode (aka SCM/SCC/CS instructions).
///
#pragma once
#include "stdinc.h"
#include "defs/game.hpp"

/// Generates bytecode from the intermediate representation T.
///
/// This function should be overloaded/specialized for each pseudo-object generated by *compiler.hpp/cpp*.
/// By default it calls `T.generate_code(codegen)`.
///
template<typename T>
void generate_code(const T&, CodeGenerator&);
void generate_code(const CompiledData& data, CodeGenerator& codegen);

///
/// This function should be overloaded/specialized for each pseudo-object generated by *compiler.hpp/cpp*.
/// By default it calls `T.compiled_size(codegen)`.
///
template<typename T>
inline size_t compiled_size(const T&, const CodeGenerator&);
size_t compiled_size(const ArgVariant&, const CodeGenerator&);
size_t compiled_size(const CompiledData&, const CodeGenerator&);


/// Converts intermediate representation (given by `CompilerContext`) into SCM bytecode.
struct CodeGenerator
{
    const GameConfig                config;

    const shared_ptr<const Script>  script;
    std::vector<CompiledData>       compiled;
    const SymTable&                 symbols;

    std::unique_ptr<uint8_t[]>      bytecode; // size == script->size
    size_t                          offset;

    CodeGenerator(GameConfig config, shared_ptr<const Script> script_, std::vector<CompiledData> compiled, const SymTable& symbols) :
        config(std::move(config)), script(std::move(script_)), compiled(std::move(compiled)), symbols(symbols)
    {
    }

    CodeGenerator(GameConfig config, CompilerContext context) : // consumes the context (faster)
        CodeGenerator(std::move(config), std::move(context.script), std::move(context.compiled), context.symbols)
    {}

    /*
    CodeGenerator(const CompilerContext& context) : // does not consume the context (slower)
    CodeGenerator(context.script, context.compiled, context.symbols)
    {}
    */

    /// Finds the `Label::local_offsets` for all labels that are inside this script.
    ///
    /// \returns the size of this script.
    ///
    /// \warning This method is not thread-safe because it modifies states! It modifies label objects which may be
    /// in use by other code generation units.
    ///
    uint32_t compute_labels() const
    {
        uint32_t offset = 0;
        for(auto& op : this->compiled)
        {
            if(is<CompiledLabelDef>(op.data))
            {
                get<CompiledLabelDef>(op.data).label->local_offset = offset;
            }
            else
            {
                offset += compiled_size(op, *this);
            }
        }
        return offset;
    }

    void generate()
    {
        this->offset = 0;
        this->bytecode.reset(new uint8_t[this->script->size.value()]);

        for(auto& op : this->compiled)
        {
            generate_code(op, *this);
        }
    }

    void emplace_u8(uint8_t value)
    {
        assert(this->offset + 1 <= *this->script->size);
        bytecode[this->offset++] = reinterpret_cast<uint8_t&>(value);
    }

    void emplace_u16(uint16_t value)
    {
        // TODO maybe optimize, write a entire i16 at a time? is that portable?
        //assert(this->offset + 2 <= *this->script->size);
        emplace_u8((value & 0x00FF) >> 0);
        emplace_u8((value & 0xFF00) >> 8);
    }

    void emplace_u32(uint32_t value)
    {
        // TODO maybe optimize, write a entire i32 at a time? is that portable?
        //assert(this->offset + 4 <= *this->script->size);
        emplace_u8((value & 0x000000FF) >> 0);
        emplace_u8((value & 0x0000FF00) >> 8);
        emplace_u8((value & 0x00FF0000) >> 16);
        emplace_u8((value & 0xFF000000) >> 24);
    }

    void emplace_i8(int8_t value)
    {
        return emplace_u8(reinterpret_cast<uint8_t&>(value));
    }

    void emplace_i16(int16_t value)
    {
        return emplace_u16(reinterpret_cast<uint16_t&>(value));
    }

    void emplace_i32(int32_t value)
    {
        return emplace_u32(reinterpret_cast<uint32_t&>(value));
    }

    void emplace_chars(size_t count, const char* data)
    {
        assert(this->offset + count <= *this->script->size);
        std::strncpy(reinterpret_cast<char*>(&this->bytecode[offset]), data, count);
        this->offset += count;
    }
};

/********/

template<typename T>
inline size_t compiled_size(const T& x, const CodeGenerator&)
{
    return x.compiled_size();
}

inline size_t compiled_size(const EOAL&, const CodeGenerator&)
{
    return 1;
}

inline size_t compiled_size(const int8_t&, const CodeGenerator&)
{
    return 1 + sizeof(int8_t);
}

inline size_t compiled_size(const int16_t&, const CodeGenerator&)
{
    return 1 + sizeof(int16_t);
}

inline size_t compiled_size(const int32_t&, const CodeGenerator&)
{
    return 1 + sizeof(int32_t);
}

inline size_t compiled_size(const float&, const CodeGenerator& codegen)
{
    if(codegen.config.use_half_float)
        return 1 + sizeof(int16_t);
    else
        return 1 + sizeof(float);
}

inline size_t compiled_size(const shared_ptr<Label>&, const CodeGenerator&)
{
    return 1 + sizeof(int32_t);
}

inline size_t compiled_size(const CompiledVar& v, const CodeGenerator&)
{
    if(v.index == nullopt)
        return 1 + sizeof(uint16_t);
    else
        return 1 + sizeof(uint16_t) * 2 + sizeof(uint8_t) * 2;
}

inline size_t compiled_size(const CompiledString& s, const CodeGenerator& codegen)
{
    switch(s.type)
    {
        case CompiledString::Type::TextLabel8:
            return (codegen.config.has_text_label_prefix? 1 : 0) + 8;
        case CompiledString::Type::TextLabel16:
            return 1 + 16;
        case CompiledString::Type::StringVar:
            return 1 + 1 + s.storage.size();
        case CompiledString::Type::String128:
            return 128;
        default:
            Unreachable();
    }
}

inline size_t compiled_size(const ArgVariant& varg, const CodeGenerator& codegen)
{
    return visit_one(varg, [&](const auto& arg) { return ::compiled_size(arg, codegen); });
}

inline size_t compiled_size(const CompiledCommand& cmd, const CodeGenerator& codegen)
{
    size_t size = sizeof(uint16_t);
    for(auto& a : cmd.args) size += ::compiled_size(a, codegen);
    return size;
}

inline size_t compiled_size(const CompiledData& data, const CodeGenerator& codegen)
{
    return visit_one(data.data, [&](const auto& data) { return ::compiled_size(data, codegen); });
}

/********/

template<typename T>
inline void generate_code(const T& x, CodeGenerator& codegen)
{
    return x.generate_code();
}

inline void generate_code(const EOAL&, CodeGenerator& codegen)
{
    codegen.emplace_u8(0);
}

inline void generate_code(const int8_t& value, CodeGenerator& codegen)
{
    codegen.emplace_u8(4);
    codegen.emplace_i8(value);
}

inline void generate_code(const int16_t& value, CodeGenerator& codegen)
{
    codegen.emplace_u8(5);
    codegen.emplace_i16(value);
}

inline void generate_code(const int32_t& value, CodeGenerator& codegen)
{
    codegen.emplace_u8(1);
    codegen.emplace_i32(value);
}

inline void generate_code(const float& value, CodeGenerator& codegen)
{
    if(codegen.config.use_half_float)
    {
        auto to_half = [](float value) -> int16_t {
            // from Wesser
            if(!value) return 0;
            value *= 16.0f;
            return static_cast<int16_t>(value + (value > 0? 0.5f : -0.5f));
        };

        codegen.emplace_u8(6);
        codegen.emplace_i16(to_half(value));
    }
    else
    {
        static_assert(std::numeric_limits<float>::is_iec559
            && sizeof(float) == sizeof(uint32_t), "IEEE 754 floating point expected.");

        codegen.emplace_u8(6);
        codegen.emplace_u32(reinterpret_cast<const uint32_t&>(value));
    }
}

inline void generate_code(const shared_ptr<Label>& label_ptr, CodeGenerator& codegen)
{
    codegen.emplace_u8(1);
    codegen.emplace_i32(label_ptr->offset());
}

inline void generate_code(const CompiledString& str, CodeGenerator& codegen)
{
    switch(str.type)
    {
        case CompiledString::Type::TextLabel8:
            if(codegen.config.has_text_label_prefix)
                codegen.emplace_u8(9);
            codegen.emplace_chars(8, str.storage.c_str());
            break;
        case CompiledString::Type::TextLabel16:
            codegen.emplace_u8(0xF);
            codegen.emplace_chars(16, str.storage.c_str());
            break;
        case CompiledString::Type::StringVar:
            codegen.emplace_u8(0xE);
            codegen.emplace_u8(str.storage.size()); // TODO CHECK SIZE <= 127!
            codegen.emplace_chars(str.storage.size(), str.storage.c_str());
            break;
        case CompiledString::Type::String128:
            codegen.emplace_chars(128, str.storage.c_str());
            break;
    }
}

inline void generate_code(const CompiledVar& v, CodeGenerator& codegen)
{
    bool global = v.var->global;

    if(v.index == nullopt)
    {
        switch(v.var->type)
        {
            case VarType::Int:
            case VarType::Float:
                codegen.emplace_u8(global? 0x2 : 0x3);
                break;
            case VarType::TextLabel:
                codegen.emplace_u8(global? 0xA : 0xB);
                break;
            case VarType::TextLabel16:
                codegen.emplace_u8(global? 0x10 : 0x11);
                break;
        }

        codegen.emplace_u16(static_cast<uint16_t>(global? v.var->offset() : v.var->index));
    }
    else
    {
        // TODO array SA only
    }
}

inline void generate_code(const ArgVariant& varg, CodeGenerator& codegen)
{
    return visit_one(varg, [&](const auto& arg) { return ::generate_code(arg, codegen); });
}

inline void generate_code(const CompiledCommand& ccmd, CodeGenerator& codegen)
{
    codegen.emplace_u16(ccmd.id);
    for(auto& arg : ccmd.args) ::generate_code(arg, codegen);
}

inline void generate_code(const CompiledLabelDef&, CodeGenerator&)
{
    // label definitions do not have a physical representation
}

inline void generate_code(const CompiledHex& hex, CodeGenerator& codegen)
{
    // TODO maybe we could have a codegen.emplace_bytes
    for(size_t i = 0; i < hex.data.size(); ++i)
        codegen.emplace_u8(hex.data[i]);
}

inline void generate_code(const CompiledData& data, CodeGenerator& codegen)
{
    return visit_one(data.data, [&](const auto& data) { return ::generate_code(data, codegen); });
}

